package j_machine

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new j machine API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for j machine API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
JMachineApprove j machine approve API
*/
func (a *Client) JMachineApprove(params *JMachineApproveParams, authInfo runtime.ClientAuthInfoWriter) (*JMachineApproveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJMachineApproveParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JMachine.approve",
		Method:             "POST",
		PathPattern:        "/remote.api/JMachine.approve/{id}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JMachineApproveReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JMachineApproveOK), nil

}

/*
JMachineDeny j machine deny API
*/
func (a *Client) JMachineDeny(params *JMachineDenyParams, authInfo runtime.ClientAuthInfoWriter) (*JMachineDenyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJMachineDenyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JMachine.deny",
		Method:             "POST",
		PathPattern:        "/remote.api/JMachine.deny/{id}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JMachineDenyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JMachineDenyOK), nil

}

/*
JMachineOne j machine one API
*/
func (a *Client) JMachineOne(params *JMachineOneParams, authInfo runtime.ClientAuthInfoWriter) (*JMachineOneOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJMachineOneParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JMachine.one",
		Method:             "POST",
		PathPattern:        "/remote.api/JMachine.one",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JMachineOneReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JMachineOneOK), nil

}

/*
JMachineReviveUsers j machine revive users API
*/
func (a *Client) JMachineReviveUsers(params *JMachineReviveUsersParams, authInfo runtime.ClientAuthInfoWriter) (*JMachineReviveUsersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJMachineReviveUsersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JMachine.reviveUsers",
		Method:             "POST",
		PathPattern:        "/remote.api/JMachine.reviveUsers/{id}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JMachineReviveUsersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JMachineReviveUsersOK), nil

}

/*
JMachineSetChannelID j machine set channel Id API
*/
func (a *Client) JMachineSetChannelID(params *JMachineSetChannelIDParams, authInfo runtime.ClientAuthInfoWriter) (*JMachineSetChannelIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJMachineSetChannelIDParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JMachine.setChannelId",
		Method:             "POST",
		PathPattern:        "/remote.api/JMachine.setChannelId/{id}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JMachineSetChannelIDReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JMachineSetChannelIDOK), nil

}

/*
JMachineSetLabel j machine set label API
*/
func (a *Client) JMachineSetLabel(params *JMachineSetLabelParams, authInfo runtime.ClientAuthInfoWriter) (*JMachineSetLabelOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJMachineSetLabelParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JMachine.setLabel",
		Method:             "POST",
		PathPattern:        "/remote.api/JMachine.setLabel/{id}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JMachineSetLabelReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JMachineSetLabelOK), nil

}

/*
JMachineSetProvisioner j machine set provisioner API
*/
func (a *Client) JMachineSetProvisioner(params *JMachineSetProvisionerParams, authInfo runtime.ClientAuthInfoWriter) (*JMachineSetProvisionerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJMachineSetProvisionerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JMachine.setProvisioner",
		Method:             "POST",
		PathPattern:        "/remote.api/JMachine.setProvisioner/{id}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JMachineSetProvisionerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JMachineSetProvisionerOK), nil

}

/*
JMachineShare j machine share API
*/
func (a *Client) JMachineShare(params *JMachineShareParams, authInfo runtime.ClientAuthInfoWriter) (*JMachineShareOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJMachineShareParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JMachine.share",
		Method:             "POST",
		PathPattern:        "/remote.api/JMachine.share/{id}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JMachineShareReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JMachineShareOK), nil

}

/*
JMachineShareWith Method JMachine.shareWith
*/
func (a *Client) JMachineShareWith(params *JMachineShareWithParams, authInfo runtime.ClientAuthInfoWriter) (*JMachineShareWithOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJMachineShareWithParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JMachine.shareWith",
		Method:             "POST",
		PathPattern:        "/remote.api/JMachine.shareWith/{id}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JMachineShareWithReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JMachineShareWithOK), nil

}

/*
JMachineSome j machine some API
*/
func (a *Client) JMachineSome(params *JMachineSomeParams, authInfo runtime.ClientAuthInfoWriter) (*JMachineSomeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJMachineSomeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JMachine.some",
		Method:             "POST",
		PathPattern:        "/remote.api/JMachine.some",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JMachineSomeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JMachineSomeOK), nil

}

/*
JMachineUnshare j machine unshare API
*/
func (a *Client) JMachineUnshare(params *JMachineUnshareParams, authInfo runtime.ClientAuthInfoWriter) (*JMachineUnshareOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJMachineUnshareParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JMachine.unshare",
		Method:             "POST",
		PathPattern:        "/remote.api/JMachine.unshare/{id}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JMachineUnshareReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JMachineUnshareOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
