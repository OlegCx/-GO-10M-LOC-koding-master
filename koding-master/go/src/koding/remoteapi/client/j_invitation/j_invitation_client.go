package j_invitation

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new j invitation API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for j invitation API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
JInvitationAccept Method JInvitation.accept
*/
func (a *Client) JInvitationAccept(params *JInvitationAcceptParams, authInfo runtime.ClientAuthInfoWriter) (*JInvitationAcceptOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJInvitationAcceptParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JInvitation.accept",
		Method:             "POST",
		PathPattern:        "/remote.api/JInvitation.accept/{id}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JInvitationAcceptReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JInvitationAcceptOK), nil

}

/*
JInvitationByCode byCode fetches an invitation by its code
*/
func (a *Client) JInvitationByCode(params *JInvitationByCodeParams, authInfo runtime.ClientAuthInfoWriter) (*JInvitationByCodeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJInvitationByCodeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JInvitation.byCode",
		Method:             "POST",
		PathPattern:        "/remote.api/JInvitation.byCode",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JInvitationByCodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JInvitationByCodeOK), nil

}

/*
JInvitationCreate j invitation create API
*/
func (a *Client) JInvitationCreate(params *JInvitationCreateParams, authInfo runtime.ClientAuthInfoWriter) (*JInvitationCreateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJInvitationCreateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JInvitation.create",
		Method:             "POST",
		PathPattern:        "/remote.api/JInvitation.create",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JInvitationCreateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JInvitationCreateOK), nil

}

/*
JInvitationRemove j invitation remove API
*/
func (a *Client) JInvitationRemove(params *JInvitationRemoveParams, authInfo runtime.ClientAuthInfoWriter) (*JInvitationRemoveOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJInvitationRemoveParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JInvitation.remove",
		Method:             "POST",
		PathPattern:        "/remote.api/JInvitation.remove/{id}",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JInvitationRemoveReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JInvitationRemoveOK), nil

}

/*
JInvitationRevokeInvitation j invitation revoke invitation API
*/
func (a *Client) JInvitationRevokeInvitation(params *JInvitationRevokeInvitationParams, authInfo runtime.ClientAuthInfoWriter) (*JInvitationRevokeInvitationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJInvitationRevokeInvitationParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JInvitation.revokeInvitation",
		Method:             "POST",
		PathPattern:        "/remote.api/JInvitation.revokeInvitation",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JInvitationRevokeInvitationReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JInvitationRevokeInvitationOK), nil

}

/*
JInvitationSearch j invitation search API
*/
func (a *Client) JInvitationSearch(params *JInvitationSearchParams, authInfo runtime.ClientAuthInfoWriter) (*JInvitationSearchOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJInvitationSearchParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JInvitation.search",
		Method:             "POST",
		PathPattern:        "/remote.api/JInvitation.search",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JInvitationSearchReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JInvitationSearchOK), nil

}

/*
JInvitationSendInvitationByCode j invitation send invitation by code API
*/
func (a *Client) JInvitationSendInvitationByCode(params *JInvitationSendInvitationByCodeParams, authInfo runtime.ClientAuthInfoWriter) (*JInvitationSendInvitationByCodeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJInvitationSendInvitationByCodeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JInvitation.sendInvitationByCode",
		Method:             "POST",
		PathPattern:        "/remote.api/JInvitation.sendInvitationByCode",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JInvitationSendInvitationByCodeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JInvitationSendInvitationByCodeOK), nil

}

/*
JInvitationSome j invitation some API
*/
func (a *Client) JInvitationSome(params *JInvitationSomeParams, authInfo runtime.ClientAuthInfoWriter) (*JInvitationSomeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJInvitationSomeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "JInvitation.some",
		Method:             "POST",
		PathPattern:        "/remote.api/JInvitation.some",
		ProducesMediaTypes: []string{""},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &JInvitationSomeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*JInvitationSomeOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
